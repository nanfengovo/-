import { w as e } from "../utils/index.js";
import { defineComponent as t, useSlots as i, computed as n, resolveComponent as l, openBlock as o, createElementBlock as s, Fragment as c, renderList as a, normalizeClass as d, createElementVNode as r, createVNode as h, unref as u, withModifiers as y, createBlock as p, createCommentVNode as k, renderSlot as f, createTextVNode as g, toDisplayString as C, withCtx as b, createSlots as x, ref as K, watch as w, onMounted as m, nextTick as v } from "vue";
import { _ as L, a as N } from "../checkbox/index2.js";
import { _ as S } from "../transition/index2.js";
const D = ["onClick"], B = { class: "layui-tree-main" }, I = ["onClick"], R = { key: 0, class: "layui-tree-pack layui-tree-showLine", style: { display: "block" } }, T = t({ name: "TreeNode", props: { tree: null, nodeList: null, showCheckbox: { type: Boolean }, showLine: { type: Boolean }, selectedKey: null, checkStrictly: { type: [Boolean, String] }, collapseTransition: { type: Boolean }, onlyIconControl: { type: Boolean }, tailNodeIcon: { type: [String, Boolean] } }, emits: ["node-click"], setup(e2, { emit: t2 }) {
  const K2 = e2;
  function w2(e3) {
    return !e3.hasNextSibling && e3.parentNode && (!e3.parentNode.hasNextSibling || e3.parentNode.hasNextSibling && !e3.parentNode.children);
  }
  i();
  const m2 = (e3) => K2.showLine ? 0 !== e3.children.length ? e3.isLeaf ? "layui-icon-subtraction" : "layui-icon-addition" : K2.tailNodeIcon ? K2.tailNodeIcon : "" : e3.children.length > 0 ? e3.isLeaf ? "layui-icon-triangle-d" : "layui-icon-triangle-r" : "";
  function v2(e3) {
    t2("node-click", e3);
  }
  function T2(e3) {
    e3.isLeaf = !e3.isLeaf;
  }
  function F2(e3) {
    K2.onlyIconControl || T2(e3), e3.isDisabled || t2("node-click", e3);
  }
  const M2 = n(() => {
    function e3(t3) {
      if (!K2.showCheckbox)
        return false;
      let i2 = 0, n2 = false;
      for (const e4 of t3.children)
        e4.isChecked && i2++;
      if (i2 > 0 && (t3.isChecked = true), i2 == t3.children.length) {
        for (const i3 of t3.children)
          if (n2 = e3(i3), n2)
            break;
      } else
        n2 = true;
      return n2;
    }
    return (t3) => {
      if (K2.checkStrictly)
        return false;
      return e3(t3);
    };
  });
  return (t3, i2) => {
    const n2 = l("tree-node", true);
    return o(true), s(c, null, a(e2.nodeList, (i3, l2) => (o(), s("div", { key: l2, class: d({ "layui-tree-set": true, "layui-tree-setLineShort": w2(i3), "layui-tree-setHide": i3.isRoot }) }, [r("div", { class: d(["layui-tree-entry", { "layui-this": e2.selectedKey === i3.id }]), onClick: (e3) => function(e4) {
      K2.showLine || F2(e4);
    }(i3) }, [r("div", B, [r("span", { class: d([e2.showLine && i3.children.length > 0 ? "layui-tree-icon" : "", { "layui-tree-iconClick": true }]) }, [h(u(L), { type: m2(i3), onClick: y((e3) => T2(i3), ["stop"]) }, null, 8, ["type", "onClick"])], 2), e2.showCheckbox ? (o(), p(N, { key: 0, value: "", skin: "primary", modelValue: i3.isChecked, disabled: i3.isDisabled, isIndeterminate: u(M2)(i3), onChange: (e3) => function(e4, t4) {
      K2.tree.setCheckedKeys(e4, K2.checkStrictly, t4);
    }(e3, i3) }, null, 8, ["modelValue", "disabled", "isIndeterminate", "onChange"])) : k("", true), r("span", { class: d({ "layui-tree-txt": true, "layui-disabled": i3.isDisabled }), onClick: y((e3) => F2(i3), ["stop"]) }, [f(t3.$slots, "title", { data: i3 }, () => [g(C(i3.title), 1)])], 10, I)])], 10, D), h(S, { enable: e2.collapseTransition }, { default: b(() => [i3.isLeaf ? (o(), s("div", R, [h(n2, { tree: e2.tree, "node-list": i3.children, "show-checkbox": e2.showCheckbox, "show-line": e2.showLine, "selected-key": e2.selectedKey, "collapse-transition": e2.collapseTransition, checkStrictly: e2.checkStrictly, "only-icon-control": e2.onlyIconControl, "tail-node-icon": e2.tailNodeIcon, onNodeClick: v2 }, x({ _: 2 }, [t3.$slots.title ? { name: "title", fn: b((e3) => [f(t3.$slots, "title", { data: e3.data })]), key: "0" } : void 0]), 1032, ["tree", "node-list", "show-checkbox", "show-line", "selected-key", "collapse-transition", "checkStrictly", "only-icon-control", "tail-node-icon"])])) : k("", true)]), _: 2 }, 1032, ["enable"])], 2))), 128);
  };
} });
class F {
  constructor(e2, t2) {
    this.config = e2, this.treeData = [], this.init(t2);
  }
  init(e2) {
    const t2 = this.createTree(e2);
    this.treeData = t2;
  }
  createTree(e2, t2 = "") {
    let i2;
    i2 = Array.isArray(e2) ? e2 : Array.of(Object.assign({}, e2));
    const n2 = [], { children: l2 } = this.config.replaceFields, o2 = i2.length;
    for (let e3 = 0; e3 < o2; e3++) {
      const s2 = this.getNode(i2[e3], t2, e3 < o2 - 1), c2 = Reflect.get(s2, l2);
      !!Reflect.get(s2, l2) && Reflect.set(s2, l2, this.createTree(c2, s2.id)), n2.push(s2);
    }
    return n2;
  }
  getNode(e2, t2, i2) {
    const { nodeMap: n2, originMap: l2, checkedKeys: o2, expandKeys: s2, replaceFields: { children: c2, id: a2, title: d2 } } = this.config, r2 = Reflect.get(e2, a2), h2 = Reflect.get(e2, d2), u2 = Reflect.get(e2, c2), y2 = !!Reflect.get(e2, "disabled"), p2 = !!Reflect.get(e2, "spread") || s2.includes(r2), k2 = n2.get(t2), f2 = Object.assign({}, e2, { id: r2, title: h2, children: u2 || [], parentKey: t2, isRoot: "" === t2, isDisabled: false, isChecked: false, isLeaf: false, hasNextSibling: i2, parentNode: k2 || null });
    return f2.isDisabled = y2, f2.isChecked = o2.includes(r2), f2.isLeaf = k2 ? k2.isLeaf : s2.includes(r2), f2.isLeaf = p2, n2.has(r2) || n2.set(r2, f2), l2.has(r2) || l2.set(r2, e2), f2;
  }
  treeForeach(e2, t2) {
    e2.forEach((e3) => {
      e3.children && this.treeForeach(e3.children, t2), t2(e3);
    });
  }
  setChildrenChecked(e2, t2) {
    var i2 = 0, n2 = 0;
    const l2 = t2.length;
    this.treeForeach(t2, (e3) => {
      e3.isDisabled || (i2 += 1, e3.isChecked && (n2 += 1));
    }), e2 = n2 < i2;
    for (let i3 = 0; i3 < l2; i3++)
      (!t2[i3].isDisabled || t2[i3].isDisabled && t2[i3].children.length > 0) && (t2[i3].isChecked = e2), t2[i3].children && t2[i3].children.length > 0 && this.setChildrenChecked(e2, t2[i3].children);
  }
  setParentChecked(e2, t2) {
    if (!t2)
      return;
    t2.isChecked = e2;
    t2.children.some((e3) => e3.isChecked) && (t2.isChecked = true), t2.parentNode && this.setParentChecked(e2, t2.parentNode);
  }
  setCheckedKeys(e2, t2, i2) {
    i2.isChecked = e2, t2 || (i2.parentNode && this.setParentChecked(e2, i2.parentNode), i2.children && this.setChildrenChecked(e2, i2.children));
  }
  getData() {
    return this.treeData;
  }
  getKeys() {
    const e2 = [], t2 = [], i2 = this.config.nodeMap[Symbol.iterator]();
    let n2 = i2.next();
    for (; !n2.done; ) {
      const [, l2] = n2.value, o2 = Reflect.get(l2, this.config.replaceFields.id);
      l2.isChecked && t2.push(o2), l2.isLeaf && e2.push(o2), n2 = i2.next();
    }
    return { checkedKeys: t2, expandKeys: e2 };
  }
  getOriginData(e2) {
    return this.config.originMap.get(e2);
  }
}
const M = t({ name: "LayTree", props: { data: null, disabled: { type: Boolean, default: false }, edit: { default: false }, checkedKeys: { default: () => [] }, expandKeys: null, checkStrictly: { type: [Boolean, String], default: false }, collapseTransition: { type: Boolean, default: true }, onlyIconControl: { type: Boolean, default: false }, selectedKey: null, showLine: { type: Boolean, default: true }, showCheckbox: { type: Boolean, default: false }, replaceFields: { default: () => ({ id: "id", children: "children", title: "title" }) }, tailNodeIcon: { type: [String, Boolean], default: "layui-icon-file" } }, emits: ["update:expandKeys", "update:checkedKeys", "node-click", "update:selectedKey"], setup(e2, { emit: t2 }) {
  const l2 = e2;
  i();
  const c2 = n(() => ({ "layui-tree": true, "layui-form": l2.showCheckbox, "layui-tree-line": l2.showLine, "layui-tree-unline": !l2.showLine }));
  let a2 = K(), r2 = K();
  const y2 = K(false), p2 = K(false), k2 = () => {
    let { tree: e3, nodeList: t3 } = ((e4, t4) => {
      var _a, _b, _c, _d;
      const i2 = new F({ nodeMap: /* @__PURE__ */ new Map(), originMap: /* @__PURE__ */ new Map(), replaceFields: { id: "id", title: "title", children: "children" }, showCheckbox: (_a = e4.showCheckbox) != null ? _a : false, checkedKeys: (_b = e4.checkedKeys) != null ? _b : [], expandKeys: (_c = e4.expandKeys) != null ? _c : [], checkStrictly: (_d = e4.checkStrictly) != null ? _d : false }, e4.data), l3 = n(() => i2.getData());
      return { tree: i2, nodeList: l3 };
    })(l2);
    a2.value = e3, r2.value = t3.value;
  };
  w(() => l2.data, () => {
    y2.value || k2();
  }, { deep: true, immediate: true }), w(() => l2.checkedKeys, () => {
    y2.value || k2();
  }), w(() => l2.expandKeys, () => {
    y2.value || k2();
  });
  const g2 = K(), C2 = K();
  function L2(e3) {
    const i2 = a2.value.getOriginData(e3.id);
    t2("update:selectedKey", e3.id), t2("node-click", i2);
  }
  w(a2, () => {
    if (p2.value) {
      const { checkedKeys: e3, expandKeys: i2 } = a2.value.getKeys();
      y2.value = true, String(C2.value) != String(e3) && (C2.value = e3, t2("update:checkedKeys", e3)), String(g2) != String(i2) && (g2.value = i2, t2("update:expandKeys", i2)), setTimeout(() => {
        y2.value = false;
      }, 0);
    }
  }, { deep: true }), m(() => {
    v(() => {
      p2.value = true;
    });
  });
  const N2 = K(l2.selectedKey);
  return w(() => l2.selectedKey, () => {
    N2.value = l2.selectedKey;
  }), (t3, i2) => (o(), s("div", { class: d(u(c2)) }, [h(T, { tree: u(a2), "node-list": u(r2), "show-checkbox": e2.showCheckbox, "show-line": e2.showLine, selectedKey: N2.value, "check-strictly": e2.checkStrictly, "collapse-transition": e2.collapseTransition, "only-icon-control": e2.onlyIconControl, "tail-node-icon": e2.tailNodeIcon, onNodeClick: L2 }, x({ _: 2 }, [t3.$slots.title ? { name: "title", fn: b(({ data: e3 }) => [f(t3.$slots, "title", { data: e3 })]), key: "0" } : void 0]), 1032, ["tree", "node-list", "show-checkbox", "show-line", "selectedKey", "check-strictly", "collapse-transition", "only-icon-control", "tail-node-icon"])], 2));
} }), _ = e(M);
export { M as _, _ as c };
