import { w as e } from "../utils/index.js";
import { defineComponent as t, useSlots as o, ref as l, toRef as n, shallowRef as i, computed as u, watch as a, onMounted as s, openBlock as f, createBlock as p, Teleport as r, withDirectives as d, createVNode as v, Transition as c, withCtx as h, createElementVNode as g, normalizeClass as y, normalizeStyle as b, renderSlot as m, createTextVNode as x, toDisplayString as B, vShow as H, createCommentVNode as k, nextTick as w, getCurrentInstance as S, createElementBlock as W, Fragment as C, mergeProps as $, unref as R } from "vue";
import { o as _, a as A, c as E, b as j } from "../_chunks/@vueuse/index.js";
const D = { top(e2, t2, o2, l2) {
  let { top: n2, left: i2, bottom: u2 } = e2.getBoundingClientRect();
  return (n2 = n2 - t2.offsetHeight - 6) < 0 && u2 > t2.offsetHeight ? (o2.value = "bottom", n2 = u2) : o2.value = "top", { top: `${n2}px`, left: i2 - (t2.offsetWidth - e2.offsetWidth) / 2 + "px" };
}, bottom(e2, t2, o2, l2) {
  let { top: n2, left: i2, bottom: u2 } = e2.getBoundingClientRect();
  return window.innerHeight - u2 < t2.offsetHeight + 6 ? (o2.value = "top", u2 = n2 - t2.offsetHeight - 6) : o2.value = "bottom", { top: `${u2}px`, left: i2 - (t2.offsetWidth - e2.offsetWidth) / 2 + "px" };
}, left(e2, t2, o2, l2) {
  let { top: n2, left: i2, right: u2 } = e2.getBoundingClientRect();
  return i2 = i2 - t2.offsetWidth - 6, i2 < 0 ? (o2.value = "right", i2 = u2) : o2.value = "left", { top: n2 - (t2.offsetHeight - e2.offsetHeight) / 2 + "px", left: `${i2}px` };
}, right(e2, t2, o2, l2) {
  let { top: n2, left: i2, right: u2 } = e2.getBoundingClientRect();
  return window.innerWidth < u2 + t2.offsetWidth + 6 ? (o2.value = "left", u2 = i2 - t2.offsetWidth - 6) : o2.value = "right", { top: n2 - (t2.offsetHeight - e2.offsetHeight) / 2 + "px", left: `${u2}px` };
} }, M = ["position"], z = g("div", { class: "layui-popper-arrow" }, null, -1), L = t({ ...{ name: "LayPopper" }, props: { el: null, position: { default: "top" }, enterable: { type: Boolean, default: true }, isDark: { type: Boolean, default: true }, disabled: { type: Boolean, default: false }, isCanHide: { type: Boolean, default: true }, isAutoShow: { type: Boolean, default: false }, visible: { type: Boolean, default: false }, content: null, trigger: { default: "hover" }, popperClass: null, popperStyle: null }, setup(e2, { expose: t2 }) {
  const S2 = e2;
  o();
  const W2 = l({ top: -window.innerHeight + "px", left: 0 }), C2 = n(S2, "el"), $2 = i({}), R2 = l(S2.position), L2 = l(S2.visible), O2 = l(S2.visible);
  let q2;
  const N = u(() => [].concat(S2.trigger)), P = function() {
    S2.disabled || (O2.value ? L2.value = true : (O2.value = true, w(() => {
      L2.value = true;
    })));
  }, T = function(e3) {
    false !== S2.isCanHide && (L2.value = false, R2.value = S2.position, W2.value = { top: -window.innerHeight + "px", left: 0 });
  }, F = function() {
    D[S2.position] && (W2.value = D[S2.position](C2.value, $2.value, R2));
  }, G = function() {
    L2.value && (0 === $2.value.offsetWidth ? w(() => F()) : F(), w(() => {
      F();
    }));
  }, I = function() {
    N.value.includes("hover") && S2.enterable && P();
  }, J = function() {
    N.value.includes("hover") && S2.enterable && T();
  }, K = function() {
    N.value.includes("click") && (L2.value ? T() : P());
  }, Q = function(e3) {
    N.value.includes("contextMenu") && (e3.preventDefault(), L2.value ? T() : P());
  }, U = function() {
    N.value.includes("hover") && P();
  }, V = function() {
    N.value.includes("hover") && T();
  }, X = function() {
    N.value.includes("focus") && S2.enterable && P();
  }, Y = function() {
    N.value.includes("focus") && S2.enterable && T();
  }, Z = j(() => {
    L2.value && G();
  }, 15);
  let ee;
  _(C2.value, (e3) => {
    !L2.value || C2.value.contains(e3.target) || $2.value.contains(e3.target) || T();
  }, { ignore: [$2.value] }), A(C2, () => {
    G();
  }), a(L2, (e3) => {
    G(), e3 ? ee = A($2, () => {
      G();
    }) : ee && ee.stop();
  }), a(() => S2.visible, (e3) => e3 ? P() : T()), a(() => S2.content, () => {
    G();
  });
  const te = function(e3) {
    return e3.scrollHeight > e3.offsetHeight || e3.scrollWidth > e3.offsetWidth;
  };
  return s(() => {
    G(), q2 = function(e3) {
      var _a;
      const t3 = [];
      let o2 = e3;
      for (; o2 && o2 !== document.documentElement; )
        te(o2) && t3.push(o2), o2 = (_a = o2.parentElement) != null ? _a : void 0;
      return t3;
    }(C2.value);
    for (const e3 of q2)
      E(e3, "scroll", Z);
    E("resize", Z), E(C2.value, "click", K), E(C2.value, "contextmenu", Q), E(C2.value, "mouseenter", U), E(C2.value, "mouseleave", V), E(C2.value, "focusin", X), E(C2.value, "focusout", Y);
  }), t2({ hide: T }), (t3, o2) => O2.value ? (f(), p(r, { key: 0, to: "body" }, [d(v(c, null, { default: h(() => {
    var _a;
    return [g("div", { ref_key: "popperRefEl", ref: $2, class: y(["layui-popper", { "layui-dark": e2.isDark }, S2.popperClass]), style: b([W2.value, (_a = S2.popperStyle) != null ? _a : ""]), position: R2.value, onMouseenter: I, onMouseleave: J }, [m(t3.$slots, "default", {}, () => [x(B(e2.content), 1)]), z], 46, M)];
  }), _: 3 }, 512), [[H, L2.value]])])) : k("", true);
} }), O = t({ name: "LayTooltip", inheritAttrs: false, props: { content: { type: [Number, String], required: false }, position: { type: String, default: "top" }, isDark: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, isCanHide: { type: Boolean, default: true }, isAutoShow: { type: Boolean, default: false }, visible: { type: Boolean, default: false }, trigger: { type: String, default: "hover" }, enterable: { type: Boolean, default: true }, popperClass: { type: [String, Array, Object] }, popperStyle: { type: [String, Object] } }, setup(e2, { expose: t2 }) {
  const o2 = e2, n2 = S(), a2 = l(false), r2 = i(void 0), d2 = l(), v2 = u(() => ({ el: n2.proxy.$el.nextElementSibling, ...n2.proxy.$props })), c2 = function() {
    var _a;
    if (r2.value) {
      let e3 = r2.value;
      e3.offsetWidth >= ((_a = e3.firstChild) == null ? void 0 : _a.offsetWidth) ? a2.value = false : a2.value = true;
    } else
      a2.value = true;
  };
  s(() => {
    o2.isAutoShow && E("resize", () => {
      c2();
    }), w(() => {
      c2();
    });
  });
  return t2({ hide: function() {
    w(() => {
      d2.value.hide();
    });
  } }), (t3, o3) => (f(), W(C, null, [e2.isAutoShow ? (f(), W("div", { key: 0, ref_key: "tooltipRefEl", ref: r2, class: "lay-tooltip-content" }, [g("span", null, [m(t3.$slots, "default")])], 512)) : m(t3.$slots, "default", { key: 1 }), a2.value ? (f(), p(L, $({ key: 2, ref_key: "popperRef", ref: d2 }, R(v2)), { default: h(() => [m(t3.$slots, "content")]), _: 3 }, 16)) : k("", true)], 64));
} }), q = e(O);
export { O as _, q as c };
