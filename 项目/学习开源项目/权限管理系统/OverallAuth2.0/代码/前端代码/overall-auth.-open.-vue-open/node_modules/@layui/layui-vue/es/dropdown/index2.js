import { i as t, a as e, b as o, w as l } from "../utils/index.js";
import { defineComponent as n, ref as s, onMounted as i, openBlock as r, createBlock as a, Teleport as u, renderSlot as c, onUpdated as d, useSlots as f, useAttrs as p, inject as h, shallowRef as v, reactive as m, toRefs as g, computed as b, onBeforeUnmount as y, watch as w, provide as C, createElementBlock as T, Fragment as B, createVNode as x, unref as O, mergeProps as L, withCtx as R, normalizeClass as F, normalizeStyle as M, createCommentVNode as k, cloneVNode as S, h as $, nextTick as E } from "vue";
import { u as P, a as D, o as W, b as A } from "../_chunks/@vueuse/index.js";
const _ = Symbol("dropdownInjectKey"), j = n({ name: "TeleportWrapper", props: { to: { default: "" }, disabled: { type: Boolean, default: false } }, setup(t2) {
  const e2 = t2, o2 = s(null);
  return i(() => {
    const t3 = new MutationObserver((t4, l2) => {
      for (const n2 of t4) {
        if ("childList" !== n2.type)
          continue;
        const t5 = document.querySelector(e2.to);
        if (t5) {
          o2.value = t5, l2.disconnect();
          break;
        }
      }
    });
    return t3.observe(document, { childList: true, subtree: true }), () => t3.disconnect();
  }), (e3, l2) => (r(), a(u, { to: o2.value, disabled: !o2.value || t2.disabled }, [c(e3.$slots, "default")], 8, ["to", "disabled"]));
} }), q = (t2) => t2.scrollHeight > t2.offsetHeight || t2.scrollWidth > t2.offsetWidth, z = (l2) => {
  var _a, _b;
  if (t(l2))
    return l2.el;
  if (!e(l2)) {
    const t2 = ((t3) => o(t3, t3.children) ? t3.children : Array.isArray(t3) ? t3 : void 0)(l2);
    return H(t2);
  }
  if (1 === ((_a = l2.el) == null ? void 0 : _a.nodeType))
    return l2.el;
  if ((_b = l2.component) == null ? void 0 : _b.subTree) {
    const t2 = z(l2.component.subTree);
    if (t2)
      return t2;
  }
}, H = (t2) => {
  if (t2 && t2.length > 0)
    for (const e2 of t2) {
      const t3 = z(e2);
      if (t3)
        return t3;
    }
};
var N = n({ name: "RenderFunction", props: { renderFunc: { type: Function, default: null } }, setup: (t2, e2) => () => "function" != typeof t2.renderFunc ? null : t2.renderFunc(e2.attrs) });
const I = n({ name: "LayDropdown", inheritAttrs: false, props: { visible: { type: Boolean, default: false }, trigger: { default: "click" }, placement: { default: "bottom-start" }, disabled: { type: Boolean, default: false }, disabledTeleport: { type: Boolean, default: false }, autoFitPosition: { type: Boolean, default: true }, autoFitWidth: { type: Boolean, default: false }, autoFitMinWidth: { type: Boolean, default: true }, updateAtScroll: { type: Boolean, default: false }, autoFixPosition: { type: Boolean, default: true }, clickToClose: { type: Boolean, default: true }, blurToClose: { type: Boolean, default: true }, clickOutsideToClose: { type: Boolean, default: true }, contentOffset: { default: 2 }, mouseEnterDelay: { default: 150 }, mouseLeaveDelay: { default: 150 }, focusDelay: { default: 150 }, alignPoint: { type: Boolean, default: false }, contentClass: null, contentStyle: null, popupContainer: { default: "body" } }, emits: ["show", "hide"], setup(t2, { expose: e2, emit: o2 }) {
  const l2 = t2, n2 = f(), a2 = p(), u2 = /* @__PURE__ */ new Set(), z2 = h(_, void 0), { children: I2, firstElement: K2 } = (() => {
    const t3 = {}, e3 = s(), o3 = () => {
      const o4 = H(t3.value);
      o4 !== e3.value && (e3.value = o4);
    };
    return i(() => o3()), d(() => o3()), { children: t3, firstElement: e3 };
  })(), X = v(), Y = s({}), { width: G, height: J } = P(), Q = m({ x: 0, y: 0 }), { x: U, y: V } = g(Q), Z = s(false);
  let tt;
  const et = b(() => {
    var _a;
    return l2.popupContainer ? (_a = document.querySelector(l2.popupContainer)) != null ? _a : document.body : K2.value;
  }), ot = b(() => [].concat(l2.trigger)), lt = b(() => ((t3) => {
    const e3 = { top: "start", left: "start", bottom: "end", right: "end" };
    if (t3.includes("-")) {
      const o3 = t3.split("-");
      return `${o3[0]}-${e3[o3[1]] || o3[1]}`;
    }
    return t3;
  })(l2.placement));
  let nt = 0;
  const st = (t3) => {
    0 == l2.disabled && (at(true, t3), o2("show"));
  }, it = (t3) => {
    at(false, t3), o2("hide");
  }, rt = () => {
    0 == l2.disabled && (Z.value ? it() : st());
  }, at = (t3, e3) => {
    if (t3 === Z.value && 0 === nt)
      return;
    const o3 = () => {
      Z.value = t3, E(() => {
        dt();
      });
    };
    e3 ? (nt && (window.clearTimeout(nt), nt = 0), t3 !== Z.value && (nt = window.setTimeout(o3, e3))) : o3();
  }, ut = (t3, e3) => {
    if (t3) {
      const o3 = t3.getBoundingClientRect();
      return { scrollTop: o3.top - e3.top, scrollBottom: o3.bottom - e3.top, scrollLeft: o3.left - e3.left, scrollRight: o3.right - e3.left, bottom: o3.bottom, height: o3.height, right: o3.right, left: o3.left, width: o3.width, top: o3.top };
    }
    return {};
  }, ct = () => ({ top: V.value, bottom: V.value, left: U.value, right: U.value, scrollTop: V.value, scrollBottom: V.value, scrollLeft: U.value, scrollRight: U.value, width: 0, height: 0 }), dt = () => {
    if (!et.value || !K2.value || !X.value)
      return;
    const t3 = et.value.getBoundingClientRect(), e3 = l2.alignPoint ? ct() : ut(K2.value, t3), o3 = ut(X.value, t3), { style: n3 } = pt(lt.value, e3, o3);
    l2.autoFitMinWidth && (n3.minWidth = `${e3.width}px`), l2.autoFitWidth && (n3.width = `${e3.width}px`), Y.value = n3, l2.autoFitPosition && E(() => {
      const e4 = l2.alignPoint ? ct() : ut(K2.value, t3), o4 = ut(X.value, t3);
      let { top: s2, left: i2 } = n3;
      s2 = Number(s2.toString().replace("px", "")), i2 = Number(i2.toString().replace("px", ""));
      const { top: r2, left: a3 } = ht(s2, i2, lt.value, e4, o4);
      n3.top = `${r2}px`, n3.left = `${a3}px`, Y.value = { ...n3 };
    });
  }, ft = (t3) => {
    if (l2.alignPoint) {
      const { pageX: e3, pageY: o3 } = t3;
      Q.x = e3, Q.y = o3;
    }
  }, pt = (t3, e3, o3, { customStyle: l3 = {} } = {}) => {
    let { top: n3, left: s2 } = vt(t3, e3, o3);
    return { style: { top: `${n3}px`, left: `${s2}px`, ...l3 } };
  }, ht = (t3, e3, o3, n3, s2) => {
    const i2 = ((t4) => ["top", "top-start", "top-end"].includes(t4) ? "top" : ["bottom", "bottom-start", "bottom-end"].includes(t4) ? "bottom" : ["left", "left-start", "left-end"].includes(t4) ? "left" : ["right", "right-start", "right-end"].includes(t4) ? "right" : "bottom")(o3);
    return ["top", "bottom"].includes(i2) && (s2.bottom > J.value && (t3 = n3.scrollTop - s2.height - l2.contentOffset), s2.top < 0 && (t3 = n3.scrollBottom + l2.contentOffset), s2.left < 0 && (e3 += 0 - s2.left), s2.right > G.value && (e3 -= s2.right - G.value)), ["left", "right"].includes(i2) && (s2.bottom > J.value && (t3 -= s2.bottom - J.value), s2.top < 0 && (t3 += 0 - s2.top), s2.left < 0 && (e3 = n3.scrollRight + l2.contentOffset), s2.right > G.value && (e3 = n3.scrollLeft - s2.width - l2.contentOffset)), { top: t3, left: e3 };
  }, vt = (t3, e3, o3) => {
    switch (t3) {
      case "top":
        return { top: e3.scrollTop - o3.height - l2.contentOffset, left: e3.scrollLeft + Math.round((e3.width - o3.width) / 2) };
      case "top-start":
        return { top: e3.scrollTop - o3.height - l2.contentOffset, left: e3.scrollLeft };
      case "top-end":
        return { top: e3.scrollTop - o3.height - l2.contentOffset, left: e3.scrollRight - o3.width };
      case "bottom":
        return { top: e3.scrollBottom + l2.contentOffset, left: e3.scrollLeft + Math.round((e3.width - o3.width) / 2) };
      case "bottom-start":
        return { top: e3.scrollBottom + l2.contentOffset, left: e3.scrollLeft };
      case "bottom-end":
        return { top: e3.scrollBottom + l2.contentOffset, left: e3.scrollRight - o3.width };
      case "right":
        return { top: e3.scrollTop + Math.round((e3.height - o3.height) / 2), left: e3.scrollRight + l2.contentOffset };
      case "right-start":
        return { top: e3.scrollTop, left: e3.scrollRight + l2.contentOffset };
      case "right-end":
        return { top: e3.scrollBottom - o3.height, left: e3.scrollRight + l2.contentOffset };
      case "left":
        return { top: e3.scrollTop + Math.round((e3.height - o3.height) / 2), left: e3.scrollLeft - o3.width - l2.contentOffset };
      case "left-start":
        return { top: e3.scrollTop, left: e3.scrollLeft - o3.width - l2.contentOffset };
      case "left-end":
        return { top: e3.scrollBottom - o3.height, left: e3.scrollLeft - o3.width - l2.contentOffset };
      default:
        return { left: 0, top: 0 };
    }
  }, mt = A(() => {
    Z.value && dt();
  }, 10), gt = (t3) => {
    l2.disabled || Z.value && !l2.clickToClose || ot.value.includes("click") && (ft(t3), rt());
  }, bt = (t3) => {
    l2.disabled || Z.value && !l2.clickToClose || ot.value.includes("contextMenu") && (t3.preventDefault(), l2.alignPoint && it(), ft(t3), rt());
  }, yt = (t3) => {
    !l2.disabled && ot.value.includes("hover") && st(l2.mouseEnterDelay);
  }, wt = (t3) => {
    l2.popupContainer && (z2 == null ? void 0 : z2.onMouseenter(t3), yt());
  }, Ct = (t3) => {
    !l2.disabled && ot.value.includes("hover") && it(l2.mouseLeaveDelay);
  }, Tt = (t3) => {
    l2.popupContainer && (z2 == null ? void 0 : z2.onMouseleave(t3), Ct());
  }, Bt = () => {
    !l2.disabled && ot.value.includes("focus") && st(l2.focusDelay);
  }, xt = () => {
    !l2.disabled && ot.value.includes("focus") && l2.blurToClose && it();
  };
  z2 == null ? void 0 : z2.addChildRef(X);
  const { stop: Ot } = D(X, () => {
    Z.value && l2.autoFixPosition && dt();
  }), { stop: Lt } = D(K2, () => {
    Z.value && l2.autoFixPosition && dt();
  });
  W(K2, (t3) => {
    var _a, _b, _c;
    if (l2.clickOutsideToClose && Z.value && !((_a = K2.value) == null ? void 0 : _a.contains(t3.target)) && !((_b = X.value) == null ? void 0 : _b.contains(t3.target))) {
      for (const e3 of u2)
        if ((_c = e3.value) == null ? void 0 : _c.contains(t3.target))
          return;
      it();
    }
  });
  const Rt = () => {
    const t3 = (n2.default ? n2.default() : []).map((t4) => S(t4, { onClick: gt, onContextmenu: bt, onMouseenter: yt, onMouseleave: Ct, onFocusin: Bt, onFocusout: xt, ...a2 }, true));
    return I2.value = t3, $(B, I2.value);
  };
  return i(() => {
    if (l2.updateAtScroll) {
      tt = ((t3) => {
        var _a;
        const e3 = [];
        let o3 = t3;
        for (; o3 && o3 !== document.documentElement; )
          q(o3) && e3.push(o3), o3 = (_a = o3.parentElement) != null ? _a : void 0;
        return e3;
      })(K2.value);
      for (const t3 of tt)
        t3.addEventListener("scroll", mt);
    }
    window.addEventListener("resize", mt);
  }), y(() => {
    if (z2 == null ? void 0 : z2.removeChildRef(X), tt) {
      for (const t3 of tt)
        t3.removeEventListener("scroll", mt);
      tt = void 0;
    }
    Ot(), Lt(), window.removeEventListener("resize", mt);
  }), w(() => l2.visible, (t3, e3) => {
    Z.value = t3;
  }, { immediate: true }), C(_, m({ onMouseenter: wt, onMouseleave: Tt, addChildRef: (t3) => {
    u2.add(t3), z2 == null ? void 0 : z2.addChildRef(t3);
  }, removeChildRef: (t3) => {
    u2.delete(t3), z2 == null ? void 0 : z2.removeChildRef(t3);
  }, hide: () => {
    it(), z2 == null ? void 0 : z2.hide();
  } })), C("openState", Z), e2({ show: st, hide: it, toggle: rt }), (e3, o3) => (r(), T(B, null, [x(O(N), L({ renderFunc: Rt }, e3.$attrs), null, 16), x(j, { to: t2.popupContainer, disabled: t2.disabledTeleport }, { default: R(() => {
    var _a;
    return [Z.value ? (r(), T("div", { key: 0, ref_key: "contentRef", ref: X, class: F(["layui-dropdown-content", "layui-anim", "layui-anim-upbit", l2.contentClass]), style: M([Y.value, (_a = l2.contentStyle) != null ? _a : ""]), onMouseenter: wt, onMouseleave: Tt }, [c(e3.$slots, "content")], 38)) : k("", true)];
  }), _: 3 }, 8, ["to", "disabled"])], 64));
} }), K = l(I);
export { N as R, I as _, K as c, _ as d };
