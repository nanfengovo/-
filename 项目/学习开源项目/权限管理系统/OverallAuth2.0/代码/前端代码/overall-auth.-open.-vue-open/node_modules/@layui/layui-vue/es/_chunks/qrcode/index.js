import { e as t } from "../encode-utf8/index.js";
import { d as e } from "../dijkstrajs/index.js";
var n = {}, r = {}, o = {};
let i;
const s = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
o.getSymbolSize = function(t2) {
  if (!t2)
    throw new Error('"version" cannot be null or undefined');
  if (t2 < 1 || t2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return 4 * t2 + 17;
}, o.getSymbolTotalCodewords = function(t2) {
  return s[t2];
}, o.getBCHDigit = function(t2) {
  let e2 = 0;
  for (; 0 !== t2; )
    e2++, t2 >>>= 1;
  return e2;
}, o.setToSJISFunction = function(t2) {
  if ("function" != typeof t2)
    throw new Error('"toSJISFunc" is not a valid function.');
  i = t2;
}, o.isKanjiModeEnabled = function() {
  return void 0 !== i;
}, o.toSJIS = function(t2) {
  return i(t2);
};
var a, u = {};
function c() {
  this.buffer = [], this.length = 0;
}
(a = u).L = { bit: 1 }, a.M = { bit: 0 }, a.Q = { bit: 3 }, a.H = { bit: 2 }, a.isValid = function(t2) {
  return t2 && void 0 !== t2.bit && t2.bit >= 0 && t2.bit < 4;
}, a.from = function(t2, e2) {
  if (a.isValid(t2))
    return t2;
  try {
    return function(t3) {
      if ("string" != typeof t3)
        throw new Error("Param is not a string");
      switch (t3.toLowerCase()) {
        case "l":
        case "low":
          return a.L;
        case "m":
        case "medium":
          return a.M;
        case "q":
        case "quartile":
          return a.Q;
        case "h":
        case "high":
          return a.H;
        default:
          throw new Error("Unknown EC Level: " + t3);
      }
    }(t2);
  } catch (t3) {
    return e2;
  }
}, c.prototype = { get: function(t2) {
  const e2 = Math.floor(t2 / 8);
  return 1 == (this.buffer[e2] >>> 7 - t2 % 8 & 1);
}, put: function(t2, e2) {
  for (let n2 = 0; n2 < e2; n2++)
    this.putBit(1 == (t2 >>> e2 - n2 - 1 & 1));
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(t2) {
  const e2 = Math.floor(this.length / 8);
  this.buffer.length <= e2 && this.buffer.push(0), t2 && (this.buffer[e2] |= 128 >>> this.length % 8), this.length++;
} };
var l = c;
function f(t2) {
  if (!t2 || t2 < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = t2, this.data = new Uint8Array(t2 * t2), this.reservedBit = new Uint8Array(t2 * t2);
}
f.prototype.set = function(t2, e2, n2, r2) {
  const o2 = t2 * this.size + e2;
  this.data[o2] = n2, r2 && (this.reservedBit[o2] = true);
}, f.prototype.get = function(t2, e2) {
  return this.data[t2 * this.size + e2];
}, f.prototype.xor = function(t2, e2, n2) {
  this.data[t2 * this.size + e2] ^= n2;
}, f.prototype.isReserved = function(t2, e2) {
  return this.reservedBit[t2 * this.size + e2];
};
var h = f, g = {};
!function(t2) {
  const e2 = o.getSymbolSize;
  t2.getRowColCoords = function(t3) {
    if (1 === t3)
      return [];
    const n2 = Math.floor(t3 / 7) + 2, r2 = e2(t3), o2 = 145 === r2 ? 26 : 2 * Math.ceil((r2 - 13) / (2 * n2 - 2)), i2 = [r2 - 7];
    for (let t4 = 1; t4 < n2 - 1; t4++)
      i2[t4] = i2[t4 - 1] - o2;
    return i2.push(6), i2.reverse();
  }, t2.getPositions = function(e3) {
    const n2 = [], r2 = t2.getRowColCoords(e3), o2 = r2.length;
    for (let t3 = 0; t3 < o2; t3++)
      for (let e4 = 0; e4 < o2; e4++)
        0 === t3 && 0 === e4 || 0 === t3 && e4 === o2 - 1 || t3 === o2 - 1 && 0 === e4 || n2.push([r2[t3], r2[e4]]);
    return n2;
  };
}(g);
var d = {};
const p = o.getSymbolSize;
d.getPositions = function(t2) {
  const e2 = p(t2);
  return [[0, 0], [e2 - 7, 0], [0, e2 - 7]];
};
var w = {};
!function(t2) {
  t2.Patterns = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
  const e2 = 3, n2 = 3, r2 = 40, o2 = 10;
  function i2(e3, n3, r3) {
    switch (e3) {
      case t2.Patterns.PATTERN000:
        return (n3 + r3) % 2 == 0;
      case t2.Patterns.PATTERN001:
        return n3 % 2 == 0;
      case t2.Patterns.PATTERN010:
        return r3 % 3 == 0;
      case t2.Patterns.PATTERN011:
        return (n3 + r3) % 3 == 0;
      case t2.Patterns.PATTERN100:
        return (Math.floor(n3 / 2) + Math.floor(r3 / 3)) % 2 == 0;
      case t2.Patterns.PATTERN101:
        return n3 * r3 % 2 + n3 * r3 % 3 == 0;
      case t2.Patterns.PATTERN110:
        return (n3 * r3 % 2 + n3 * r3 % 3) % 2 == 0;
      case t2.Patterns.PATTERN111:
        return (n3 * r3 % 3 + (n3 + r3) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + e3);
    }
  }
  t2.isValid = function(t3) {
    return null != t3 && "" !== t3 && !isNaN(t3) && t3 >= 0 && t3 <= 7;
  }, t2.from = function(e3) {
    return t2.isValid(e3) ? parseInt(e3, 10) : void 0;
  }, t2.getPenaltyN1 = function(t3) {
    const n3 = t3.size;
    let r3 = 0, o3 = 0, i3 = 0, s2 = null, a2 = null;
    for (let u2 = 0; u2 < n3; u2++) {
      o3 = i3 = 0, s2 = a2 = null;
      for (let c2 = 0; c2 < n3; c2++) {
        let n4 = t3.get(u2, c2);
        n4 === s2 ? o3++ : (o3 >= 5 && (r3 += e2 + (o3 - 5)), s2 = n4, o3 = 1), n4 = t3.get(c2, u2), n4 === a2 ? i3++ : (i3 >= 5 && (r3 += e2 + (i3 - 5)), a2 = n4, i3 = 1);
      }
      o3 >= 5 && (r3 += e2 + (o3 - 5)), i3 >= 5 && (r3 += e2 + (i3 - 5));
    }
    return r3;
  }, t2.getPenaltyN2 = function(t3) {
    const e3 = t3.size;
    let r3 = 0;
    for (let n3 = 0; n3 < e3 - 1; n3++)
      for (let o3 = 0; o3 < e3 - 1; o3++) {
        const e4 = t3.get(n3, o3) + t3.get(n3, o3 + 1) + t3.get(n3 + 1, o3) + t3.get(n3 + 1, o3 + 1);
        4 !== e4 && 0 !== e4 || r3++;
      }
    return r3 * n2;
  }, t2.getPenaltyN3 = function(t3) {
    const e3 = t3.size;
    let n3 = 0, o3 = 0, i3 = 0;
    for (let r3 = 0; r3 < e3; r3++) {
      o3 = i3 = 0;
      for (let s2 = 0; s2 < e3; s2++)
        o3 = o3 << 1 & 2047 | t3.get(r3, s2), s2 >= 10 && (1488 === o3 || 93 === o3) && n3++, i3 = i3 << 1 & 2047 | t3.get(s2, r3), s2 >= 10 && (1488 === i3 || 93 === i3) && n3++;
    }
    return n3 * r2;
  }, t2.getPenaltyN4 = function(t3) {
    let e3 = 0;
    const n3 = t3.data.length;
    for (let r3 = 0; r3 < n3; r3++)
      e3 += t3.data[r3];
    return Math.abs(Math.ceil(100 * e3 / n3 / 5) - 10) * o2;
  }, t2.applyMask = function(t3, e3) {
    const n3 = e3.size;
    for (let r3 = 0; r3 < n3; r3++)
      for (let o3 = 0; o3 < n3; o3++)
        e3.isReserved(o3, r3) || e3.xor(o3, r3, i2(t3, o3, r3));
  }, t2.getBestMask = function(e3, n3) {
    const r3 = Object.keys(t2.Patterns).length;
    let o3 = 0, i3 = 1 / 0;
    for (let s2 = 0; s2 < r3; s2++) {
      n3(s2), t2.applyMask(s2, e3);
      const r4 = t2.getPenaltyN1(e3) + t2.getPenaltyN2(e3) + t2.getPenaltyN3(e3) + t2.getPenaltyN4(e3);
      t2.applyMask(s2, e3), r4 < i3 && (i3 = r4, o3 = s2);
    }
    return o3;
  };
}(w);
var m = {};
const E = u, y = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81], A = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
m.getBlocksCount = function(t2, e2) {
  switch (e2) {
    case E.L:
      return y[4 * (t2 - 1) + 0];
    case E.M:
      return y[4 * (t2 - 1) + 1];
    case E.Q:
      return y[4 * (t2 - 1) + 2];
    case E.H:
      return y[4 * (t2 - 1) + 3];
    default:
      return;
  }
}, m.getTotalCodewordsCount = function(t2, e2) {
  switch (e2) {
    case E.L:
      return A[4 * (t2 - 1) + 0];
    case E.M:
      return A[4 * (t2 - 1) + 1];
    case E.Q:
      return A[4 * (t2 - 1) + 2];
    case E.H:
      return A[4 * (t2 - 1) + 3];
    default:
      return;
  }
};
var C = {}, B = {};
const I = new Uint8Array(512), M = new Uint8Array(256);
!function() {
  let t2 = 1;
  for (let e2 = 0; e2 < 255; e2++)
    I[e2] = t2, M[t2] = e2, t2 <<= 1, 256 & t2 && (t2 ^= 285);
  for (let t3 = 255; t3 < 512; t3++)
    I[t3] = I[t3 - 255];
}(), B.log = function(t2) {
  if (t2 < 1)
    throw new Error("log(" + t2 + ")");
  return M[t2];
}, B.exp = function(t2) {
  return I[t2];
}, B.mul = function(t2, e2) {
  return 0 === t2 || 0 === e2 ? 0 : I[M[t2] + M[e2]];
}, function(t2) {
  const e2 = B;
  t2.mul = function(t3, n2) {
    const r2 = new Uint8Array(t3.length + n2.length - 1);
    for (let o2 = 0; o2 < t3.length; o2++)
      for (let i2 = 0; i2 < n2.length; i2++)
        r2[o2 + i2] ^= e2.mul(t3[o2], n2[i2]);
    return r2;
  }, t2.mod = function(t3, n2) {
    let r2 = new Uint8Array(t3);
    for (; r2.length - n2.length >= 0; ) {
      const t4 = r2[0];
      for (let o3 = 0; o3 < n2.length; o3++)
        r2[o3] ^= e2.mul(n2[o3], t4);
      let o2 = 0;
      for (; o2 < r2.length && 0 === r2[o2]; )
        o2++;
      r2 = r2.slice(o2);
    }
    return r2;
  }, t2.generateECPolynomial = function(n2) {
    let r2 = new Uint8Array([1]);
    for (let o2 = 0; o2 < n2; o2++)
      r2 = t2.mul(r2, new Uint8Array([1, e2.exp(o2)]));
    return r2;
  };
}(C);
const v = C;
function T(t2) {
  this.genPoly = void 0, this.degree = t2, this.degree && this.initialize(this.degree);
}
T.prototype.initialize = function(t2) {
  this.degree = t2, this.genPoly = v.generateECPolynomial(this.degree);
}, T.prototype.encode = function(t2) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  const e2 = new Uint8Array(t2.length + this.degree);
  e2.set(t2);
  const n2 = v.mod(e2, this.genPoly), r2 = this.degree - n2.length;
  if (r2 > 0) {
    const t3 = new Uint8Array(this.degree);
    return t3.set(n2, r2), t3;
  }
  return n2;
};
var N = T, P = {}, b = {}, R = { isValid: function(t2) {
  return !isNaN(t2) && t2 >= 1 && t2 <= 40;
} }, L = {};
const U = "[0-9]+";
let S = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
S = S.replace(/u/g, "\\u");
const x = "(?:(?![A-Z0-9 $%*+\\-./:]|" + S + ")(?:.|[\r\n]))+";
L.KANJI = new RegExp(S, "g"), L.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), L.BYTE = new RegExp(x, "g"), L.NUMERIC = new RegExp(U, "g"), L.ALPHANUMERIC = new RegExp("[A-Z $%*+\\-./:]+", "g");
const k = new RegExp("^" + S + "$"), F = new RegExp("^" + U + "$"), z = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
L.testKanji = function(t2) {
  return k.test(t2);
}, L.testNumeric = function(t2) {
  return F.test(t2);
}, L.testAlphanumeric = function(t2) {
  return z.test(t2);
}, function(t2) {
  const e2 = R, n2 = L;
  t2.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }, t2.ALPHANUMERIC = { id: "Alphanumeric", bit: 2, ccBits: [9, 11, 13] }, t2.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }, t2.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }, t2.MIXED = { bit: -1 }, t2.getCharCountIndicator = function(t3, n3) {
    if (!t3.ccBits)
      throw new Error("Invalid mode: " + t3);
    if (!e2.isValid(n3))
      throw new Error("Invalid version: " + n3);
    return n3 >= 1 && n3 < 10 ? t3.ccBits[0] : n3 < 27 ? t3.ccBits[1] : t3.ccBits[2];
  }, t2.getBestModeForData = function(e3) {
    return n2.testNumeric(e3) ? t2.NUMERIC : n2.testAlphanumeric(e3) ? t2.ALPHANUMERIC : n2.testKanji(e3) ? t2.KANJI : t2.BYTE;
  }, t2.toString = function(t3) {
    if (t3 && t3.id)
      return t3.id;
    throw new Error("Invalid mode");
  }, t2.isValid = function(t3) {
    return t3 && t3.bit && t3.ccBits;
  }, t2.from = function(e3, n3) {
    if (t2.isValid(e3))
      return e3;
    try {
      return function(e4) {
        if ("string" != typeof e4)
          throw new Error("Param is not a string");
        switch (e4.toLowerCase()) {
          case "numeric":
            return t2.NUMERIC;
          case "alphanumeric":
            return t2.ALPHANUMERIC;
          case "kanji":
            return t2.KANJI;
          case "byte":
            return t2.BYTE;
          default:
            throw new Error("Unknown mode: " + e4);
        }
      }(e3);
    } catch (t3) {
      return n3;
    }
  };
}(b), function(t2) {
  const e2 = o, n2 = m, r2 = u, i2 = b, s2 = R, a2 = e2.getBCHDigit(7973);
  function c2(t3, e3) {
    return i2.getCharCountIndicator(t3, e3) + 4;
  }
  function l2(t3, e3) {
    let n3 = 0;
    return t3.forEach(function(t4) {
      const r3 = c2(t4.mode, e3);
      n3 += r3 + t4.getBitsLength();
    }), n3;
  }
  t2.from = function(t3, e3) {
    return s2.isValid(t3) ? parseInt(t3, 10) : e3;
  }, t2.getCapacity = function(t3, r3, o2) {
    if (!s2.isValid(t3))
      throw new Error("Invalid QR Code version");
    void 0 === o2 && (o2 = i2.BYTE);
    const a3 = 8 * (e2.getSymbolTotalCodewords(t3) - n2.getTotalCodewordsCount(t3, r3));
    if (o2 === i2.MIXED)
      return a3;
    const u2 = a3 - c2(o2, t3);
    switch (o2) {
      case i2.NUMERIC:
        return Math.floor(u2 / 10 * 3);
      case i2.ALPHANUMERIC:
        return Math.floor(u2 / 11 * 2);
      case i2.KANJI:
        return Math.floor(u2 / 13);
      case i2.BYTE:
      default:
        return Math.floor(u2 / 8);
    }
  }, t2.getBestVersionForData = function(e3, n3) {
    let o2;
    const s3 = r2.from(n3, r2.M);
    if (Array.isArray(e3)) {
      if (e3.length > 1)
        return function(e4, n4) {
          for (let r3 = 1; r3 <= 40; r3++)
            if (l2(e4, r3) <= t2.getCapacity(r3, n4, i2.MIXED))
              return r3;
        }(e3, s3);
      if (0 === e3.length)
        return 1;
      o2 = e3[0];
    } else
      o2 = e3;
    return function(e4, n4, r3) {
      for (let o3 = 1; o3 <= 40; o3++)
        if (n4 <= t2.getCapacity(o3, r3, e4))
          return o3;
    }(o2.mode, o2.getLength(), s3);
  }, t2.getEncodedBits = function(t3) {
    if (!s2.isValid(t3) || t3 < 7)
      throw new Error("Invalid QR Code version");
    let n3 = t3 << 12;
    for (; e2.getBCHDigit(n3) - a2 >= 0; )
      n3 ^= 7973 << e2.getBCHDigit(n3) - a2;
    return t3 << 12 | n3;
  };
}(P);
var D = {};
const H = o, J = H.getBCHDigit(1335);
D.getEncodedBits = function(t2, e2) {
  const n2 = t2.bit << 3 | e2;
  let r2 = n2 << 10;
  for (; H.getBCHDigit(r2) - J >= 0; )
    r2 ^= 1335 << H.getBCHDigit(r2) - J;
  return 21522 ^ (n2 << 10 | r2);
};
var K = {};
const Y = b;
function j(t2) {
  this.mode = Y.NUMERIC, this.data = t2.toString();
}
j.getBitsLength = function(t2) {
  return 10 * Math.floor(t2 / 3) + (t2 % 3 ? t2 % 3 * 3 + 1 : 0);
}, j.prototype.getLength = function() {
  return this.data.length;
}, j.prototype.getBitsLength = function() {
  return j.getBitsLength(this.data.length);
}, j.prototype.write = function(t2) {
  let e2, n2, r2;
  for (e2 = 0; e2 + 3 <= this.data.length; e2 += 3)
    n2 = this.data.substr(e2, 3), r2 = parseInt(n2, 10), t2.put(r2, 10);
  const o2 = this.data.length - e2;
  o2 > 0 && (n2 = this.data.substr(e2), r2 = parseInt(n2, 10), t2.put(r2, 3 * o2 + 1));
};
var V = j;
const O = b, Q = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function $(t2) {
  this.mode = O.ALPHANUMERIC, this.data = t2;
}
$.getBitsLength = function(t2) {
  return 11 * Math.floor(t2 / 2) + t2 % 2 * 6;
}, $.prototype.getLength = function() {
  return this.data.length;
}, $.prototype.getBitsLength = function() {
  return $.getBitsLength(this.data.length);
}, $.prototype.write = function(t2) {
  let e2;
  for (e2 = 0; e2 + 2 <= this.data.length; e2 += 2) {
    let n2 = 45 * Q.indexOf(this.data[e2]);
    n2 += Q.indexOf(this.data[e2 + 1]), t2.put(n2, 11);
  }
  this.data.length % 2 && t2.put(Q.indexOf(this.data[e2]), 6);
};
var q = $;
const Z = t, X = b;
function W(t2) {
  this.mode = X.BYTE, this.data = new Uint8Array(Z(t2));
}
W.getBitsLength = function(t2) {
  return 8 * t2;
}, W.prototype.getLength = function() {
  return this.data.length;
}, W.prototype.getBitsLength = function() {
  return W.getBitsLength(this.data.length);
}, W.prototype.write = function(t2) {
  for (let e2 = 0, n2 = this.data.length; e2 < n2; e2++)
    t2.put(this.data[e2], 8);
};
var _ = W;
const G = b, tt = o;
function et(t2) {
  this.mode = G.KANJI, this.data = t2;
}
et.getBitsLength = function(t2) {
  return 13 * t2;
}, et.prototype.getLength = function() {
  return this.data.length;
}, et.prototype.getBitsLength = function() {
  return et.getBitsLength(this.data.length);
}, et.prototype.write = function(t2) {
  let e2;
  for (e2 = 0; e2 < this.data.length; e2++) {
    let n2 = tt.toSJIS(this.data[e2]);
    if (n2 >= 33088 && n2 <= 40956)
      n2 -= 33088;
    else {
      if (!(n2 >= 57408 && n2 <= 60351))
        throw new Error("Invalid SJIS character: " + this.data[e2] + "\nMake sure your charset is UTF-8");
      n2 -= 49472;
    }
    n2 = 192 * (n2 >>> 8 & 255) + (255 & n2), t2.put(n2, 13);
  }
};
var nt = et;
!function(t2) {
  const n2 = b, r2 = V, i2 = q, s2 = _, a2 = nt, u2 = L, c2 = o, l2 = e.exports;
  function f2(t3) {
    return unescape(encodeURIComponent(t3)).length;
  }
  function h2(t3, e2, n3) {
    const r3 = [];
    let o2;
    for (; null !== (o2 = t3.exec(n3)); )
      r3.push({ data: o2[0], index: o2.index, mode: e2, length: o2[0].length });
    return r3;
  }
  function g2(t3) {
    const e2 = h2(u2.NUMERIC, n2.NUMERIC, t3), r3 = h2(u2.ALPHANUMERIC, n2.ALPHANUMERIC, t3);
    let o2, i3;
    c2.isKanjiModeEnabled() ? (o2 = h2(u2.BYTE, n2.BYTE, t3), i3 = h2(u2.KANJI, n2.KANJI, t3)) : (o2 = h2(u2.BYTE_KANJI, n2.BYTE, t3), i3 = []);
    return e2.concat(r3, o2, i3).sort(function(t4, e3) {
      return t4.index - e3.index;
    }).map(function(t4) {
      return { data: t4.data, mode: t4.mode, length: t4.length };
    });
  }
  function d2(t3, e2) {
    switch (e2) {
      case n2.NUMERIC:
        return r2.getBitsLength(t3);
      case n2.ALPHANUMERIC:
        return i2.getBitsLength(t3);
      case n2.KANJI:
        return a2.getBitsLength(t3);
      case n2.BYTE:
        return s2.getBitsLength(t3);
    }
  }
  function p2(t3, e2) {
    let o2;
    const u3 = n2.getBestModeForData(t3);
    if (o2 = n2.from(e2, u3), o2 !== n2.BYTE && o2.bit < u3.bit)
      throw new Error('"' + t3 + '" cannot be encoded with mode ' + n2.toString(o2) + ".\n Suggested mode is: " + n2.toString(u3));
    switch (o2 !== n2.KANJI || c2.isKanjiModeEnabled() || (o2 = n2.BYTE), o2) {
      case n2.NUMERIC:
        return new r2(t3);
      case n2.ALPHANUMERIC:
        return new i2(t3);
      case n2.KANJI:
        return new a2(t3);
      case n2.BYTE:
        return new s2(t3);
    }
  }
  t2.fromArray = function(t3) {
    return t3.reduce(function(t4, e2) {
      return "string" == typeof e2 ? t4.push(p2(e2, null)) : e2.data && t4.push(p2(e2.data, e2.mode)), t4;
    }, []);
  }, t2.fromString = function(e2, r3) {
    const o2 = function(t3) {
      const e3 = [];
      for (let r4 = 0; r4 < t3.length; r4++) {
        const o3 = t3[r4];
        switch (o3.mode) {
          case n2.NUMERIC:
            e3.push([o3, { data: o3.data, mode: n2.ALPHANUMERIC, length: o3.length }, { data: o3.data, mode: n2.BYTE, length: o3.length }]);
            break;
          case n2.ALPHANUMERIC:
            e3.push([o3, { data: o3.data, mode: n2.BYTE, length: o3.length }]);
            break;
          case n2.KANJI:
            e3.push([o3, { data: o3.data, mode: n2.BYTE, length: f2(o3.data) }]);
            break;
          case n2.BYTE:
            e3.push([{ data: o3.data, mode: n2.BYTE, length: f2(o3.data) }]);
        }
      }
      return e3;
    }(g2(e2, c2.isKanjiModeEnabled())), i3 = function(t3, e3) {
      const r4 = {}, o3 = { start: {} };
      let i4 = ["start"];
      for (let s4 = 0; s4 < t3.length; s4++) {
        const a4 = t3[s4], u3 = [];
        for (let t4 = 0; t4 < a4.length; t4++) {
          const c3 = a4[t4], l3 = "" + s4 + t4;
          u3.push(l3), r4[l3] = { node: c3, lastCount: 0 }, o3[l3] = {};
          for (let t5 = 0; t5 < i4.length; t5++) {
            const s5 = i4[t5];
            r4[s5] && r4[s5].node.mode === c3.mode ? (o3[s5][l3] = d2(r4[s5].lastCount + c3.length, c3.mode) - d2(r4[s5].lastCount, c3.mode), r4[s5].lastCount += c3.length) : (r4[s5] && (r4[s5].lastCount = c3.length), o3[s5][l3] = d2(c3.length, c3.mode) + 4 + n2.getCharCountIndicator(c3.mode, e3));
          }
        }
        i4 = u3;
      }
      for (let t4 = 0; t4 < i4.length; t4++)
        o3[i4[t4]].end = 0;
      return { map: o3, table: r4 };
    }(o2, r3), s3 = l2.find_path(i3.map, "start", "end"), a3 = [];
    for (let t3 = 1; t3 < s3.length - 1; t3++)
      a3.push(i3.table[s3[t3]].node);
    return t2.fromArray(function(t3) {
      return t3.reduce(function(t4, e3) {
        const n3 = t4.length - 1 >= 0 ? t4[t4.length - 1] : null;
        return n3 && n3.mode === e3.mode ? (t4[t4.length - 1].data += e3.data, t4) : (t4.push(e3), t4);
      }, []);
    }(a3));
  }, t2.rawSplit = function(e2) {
    return t2.fromArray(g2(e2, c2.isKanjiModeEnabled()));
  };
}(K);
const rt = o, ot = u, it = l, st = h, at = g, ut = d, ct = w, lt = m, ft = N, ht = P, gt = D, dt = b, pt = K;
function wt(t2, e2, n2) {
  const r2 = t2.size, o2 = gt.getEncodedBits(e2, n2);
  let i2, s2;
  for (i2 = 0; i2 < 15; i2++)
    s2 = 1 == (o2 >> i2 & 1), i2 < 6 ? t2.set(i2, 8, s2, true) : i2 < 8 ? t2.set(i2 + 1, 8, s2, true) : t2.set(r2 - 15 + i2, 8, s2, true), i2 < 8 ? t2.set(8, r2 - i2 - 1, s2, true) : i2 < 9 ? t2.set(8, 15 - i2 - 1 + 1, s2, true) : t2.set(8, 15 - i2 - 1, s2, true);
  t2.set(r2 - 8, 8, 1, true);
}
function mt(t2, e2, n2) {
  const r2 = new it();
  n2.forEach(function(e3) {
    r2.put(e3.mode.bit, 4), r2.put(e3.getLength(), dt.getCharCountIndicator(e3.mode, t2)), e3.write(r2);
  });
  const o2 = 8 * (rt.getSymbolTotalCodewords(t2) - lt.getTotalCodewordsCount(t2, e2));
  for (r2.getLengthInBits() + 4 <= o2 && r2.put(0, 4); r2.getLengthInBits() % 8 != 0; )
    r2.putBit(0);
  const i2 = (o2 - r2.getLengthInBits()) / 8;
  for (let t3 = 0; t3 < i2; t3++)
    r2.put(t3 % 2 ? 17 : 236, 8);
  return function(t3, e3, n3) {
    const r3 = rt.getSymbolTotalCodewords(e3), o3 = lt.getTotalCodewordsCount(e3, n3), i3 = r3 - o3, s2 = lt.getBlocksCount(e3, n3), a2 = r3 % s2, u2 = s2 - a2, c2 = Math.floor(r3 / s2), l2 = Math.floor(i3 / s2), f2 = l2 + 1, h2 = c2 - l2, g2 = new ft(h2);
    let d2 = 0;
    const p2 = new Array(s2), w2 = new Array(s2);
    let m2 = 0;
    const E2 = new Uint8Array(t3.buffer);
    for (let t4 = 0; t4 < s2; t4++) {
      const e4 = t4 < u2 ? l2 : f2;
      p2[t4] = E2.slice(d2, d2 + e4), w2[t4] = g2.encode(p2[t4]), d2 += e4, m2 = Math.max(m2, e4);
    }
    const y2 = new Uint8Array(r3);
    let A2, C2, B2 = 0;
    for (A2 = 0; A2 < m2; A2++)
      for (C2 = 0; C2 < s2; C2++)
        A2 < p2[C2].length && (y2[B2++] = p2[C2][A2]);
    for (A2 = 0; A2 < h2; A2++)
      for (C2 = 0; C2 < s2; C2++)
        y2[B2++] = w2[C2][A2];
    return y2;
  }(r2, t2, e2);
}
function Et(t2, e2, n2, r2) {
  let o2;
  if (Array.isArray(t2))
    o2 = pt.fromArray(t2);
  else {
    if ("string" != typeof t2)
      throw new Error("Invalid data");
    {
      let r3 = e2;
      if (!r3) {
        const e3 = pt.rawSplit(t2);
        r3 = ht.getBestVersionForData(e3, n2);
      }
      o2 = pt.fromString(t2, r3 || 40);
    }
  }
  const i2 = ht.getBestVersionForData(o2, n2);
  if (!i2)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (e2) {
    if (e2 < i2)
      throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + i2 + ".\n");
  } else
    e2 = i2;
  const s2 = mt(e2, n2, o2), a2 = rt.getSymbolSize(e2), u2 = new st(a2);
  return function(t3, e3) {
    const n3 = t3.size, r3 = ut.getPositions(e3);
    for (let e4 = 0; e4 < r3.length; e4++) {
      const o3 = r3[e4][0], i3 = r3[e4][1];
      for (let e5 = -1; e5 <= 7; e5++)
        if (!(o3 + e5 <= -1 || n3 <= o3 + e5))
          for (let r4 = -1; r4 <= 7; r4++)
            i3 + r4 <= -1 || n3 <= i3 + r4 || (e5 >= 0 && e5 <= 6 && (0 === r4 || 6 === r4) || r4 >= 0 && r4 <= 6 && (0 === e5 || 6 === e5) || e5 >= 2 && e5 <= 4 && r4 >= 2 && r4 <= 4 ? t3.set(o3 + e5, i3 + r4, true, true) : t3.set(o3 + e5, i3 + r4, false, true));
    }
  }(u2, e2), function(t3) {
    const e3 = t3.size;
    for (let n3 = 8; n3 < e3 - 8; n3++) {
      const e4 = n3 % 2 == 0;
      t3.set(n3, 6, e4, true), t3.set(6, n3, e4, true);
    }
  }(u2), function(t3, e3) {
    const n3 = at.getPositions(e3);
    for (let e4 = 0; e4 < n3.length; e4++) {
      const r3 = n3[e4][0], o3 = n3[e4][1];
      for (let e5 = -2; e5 <= 2; e5++)
        for (let n4 = -2; n4 <= 2; n4++)
          -2 === e5 || 2 === e5 || -2 === n4 || 2 === n4 || 0 === e5 && 0 === n4 ? t3.set(r3 + e5, o3 + n4, true, true) : t3.set(r3 + e5, o3 + n4, false, true);
    }
  }(u2, e2), wt(u2, n2, 0), e2 >= 7 && function(t3, e3) {
    const n3 = t3.size, r3 = ht.getEncodedBits(e3);
    let o3, i3, s3;
    for (let e4 = 0; e4 < 18; e4++)
      o3 = Math.floor(e4 / 3), i3 = e4 % 3 + n3 - 8 - 3, s3 = 1 == (r3 >> e4 & 1), t3.set(o3, i3, s3, true), t3.set(i3, o3, s3, true);
  }(u2, e2), function(t3, e3) {
    const n3 = t3.size;
    let r3 = -1, o3 = n3 - 1, i3 = 7, s3 = 0;
    for (let a3 = n3 - 1; a3 > 0; a3 -= 2)
      for (6 === a3 && a3--; ; ) {
        for (let n4 = 0; n4 < 2; n4++)
          if (!t3.isReserved(o3, a3 - n4)) {
            let r4 = false;
            s3 < e3.length && (r4 = 1 == (e3[s3] >>> i3 & 1)), t3.set(o3, a3 - n4, r4), i3--, -1 === i3 && (s3++, i3 = 7);
          }
        if (o3 += r3, o3 < 0 || n3 <= o3) {
          o3 -= r3, r3 = -r3;
          break;
        }
      }
  }(u2, s2), isNaN(r2) && (r2 = ct.getBestMask(u2, wt.bind(null, u2, n2))), ct.applyMask(r2, u2), wt(u2, n2, r2), { modules: u2, version: e2, errorCorrectionLevel: n2, maskPattern: r2, segments: o2 };
}
r.create = function(t2, e2) {
  if (void 0 === t2 || "" === t2)
    throw new Error("No input text");
  let n2, r2, o2 = ot.M;
  return void 0 !== e2 && (o2 = ot.from(e2.errorCorrectionLevel, ot.M), n2 = ht.from(e2.version), r2 = ct.from(e2.maskPattern), e2.toSJISFunc && rt.setToSJISFunction(e2.toSJISFunc)), Et(t2, n2, o2, r2);
};
var yt = {}, At = {};
!function(t2) {
  function e2(t3) {
    if ("number" == typeof t3 && (t3 = t3.toString()), "string" != typeof t3)
      throw new Error("Color should be defined as hex string");
    let e3 = t3.slice().replace("#", "").split("");
    if (e3.length < 3 || 5 === e3.length || e3.length > 8)
      throw new Error("Invalid hex color: " + t3);
    3 !== e3.length && 4 !== e3.length || (e3 = Array.prototype.concat.apply([], e3.map(function(t4) {
      return [t4, t4];
    }))), 6 === e3.length && e3.push("F", "F");
    const n2 = parseInt(e3.join(""), 16);
    return { r: n2 >> 24 & 255, g: n2 >> 16 & 255, b: n2 >> 8 & 255, a: 255 & n2, hex: "#" + e3.slice(0, 6).join("") };
  }
  t2.getOptions = function(t3) {
    t3 || (t3 = {}), t3.color || (t3.color = {});
    const n2 = void 0 === t3.margin || null === t3.margin || t3.margin < 0 ? 4 : t3.margin, r2 = t3.width && t3.width >= 21 ? t3.width : void 0, o2 = t3.scale || 4;
    return { width: r2, scale: r2 ? 4 : o2, margin: n2, color: { dark: e2(t3.color.dark || "#000000ff"), light: e2(t3.color.light || "#ffffffff") }, type: t3.type, rendererOpts: t3.rendererOpts || {} };
  }, t2.getScale = function(t3, e3) {
    return e3.width && e3.width >= t3 + 2 * e3.margin ? e3.width / (t3 + 2 * e3.margin) : e3.scale;
  }, t2.getImageWidth = function(e3, n2) {
    const r2 = t2.getScale(e3, n2);
    return Math.floor((e3 + 2 * n2.margin) * r2);
  }, t2.qrToImageData = function(e3, n2, r2) {
    const o2 = n2.modules.size, i2 = n2.modules.data, s2 = t2.getScale(o2, r2), a2 = Math.floor((o2 + 2 * r2.margin) * s2), u2 = r2.margin * s2, c2 = [r2.color.light, r2.color.dark];
    for (let t3 = 0; t3 < a2; t3++)
      for (let n3 = 0; n3 < a2; n3++) {
        let l2 = 4 * (t3 * a2 + n3), f2 = r2.color.light;
        if (t3 >= u2 && n3 >= u2 && t3 < a2 - u2 && n3 < a2 - u2) {
          f2 = c2[i2[Math.floor((t3 - u2) / s2) * o2 + Math.floor((n3 - u2) / s2)] ? 1 : 0];
        }
        e3[l2++] = f2.r, e3[l2++] = f2.g, e3[l2++] = f2.b, e3[l2] = f2.a;
      }
  };
}(At), function(t2) {
  const e2 = At;
  t2.render = function(t3, n2, r2) {
    let o2 = r2, i2 = n2;
    void 0 !== o2 || n2 && n2.getContext || (o2 = n2, n2 = void 0), n2 || (i2 = function() {
      try {
        return document.createElement("canvas");
      } catch (t4) {
        throw new Error("You need to specify a canvas element");
      }
    }()), o2 = e2.getOptions(o2);
    const s2 = e2.getImageWidth(t3.modules.size, o2), a2 = i2.getContext("2d"), u2 = a2.createImageData(s2, s2);
    return e2.qrToImageData(u2.data, t3, o2), function(t4, e3, n3) {
      t4.clearRect(0, 0, e3.width, e3.height), e3.style || (e3.style = {}), e3.height = n3, e3.width = n3, e3.style.height = n3 + "px", e3.style.width = n3 + "px";
    }(a2, i2, s2), a2.putImageData(u2, 0, 0), i2;
  }, t2.renderToDataURL = function(e3, n2, r2) {
    let o2 = r2;
    void 0 !== o2 || n2 && n2.getContext || (o2 = n2, n2 = void 0), o2 || (o2 = {});
    const i2 = t2.render(e3, n2, o2), s2 = o2.type || "image/png", a2 = o2.rendererOpts || {};
    return i2.toDataURL(s2, a2.quality);
  };
}(yt);
var Ct = {};
const Bt = At;
function It(t2, e2) {
  const n2 = t2.a / 255, r2 = e2 + '="' + t2.hex + '"';
  return n2 < 1 ? r2 + " " + e2 + '-opacity="' + n2.toFixed(2).slice(1) + '"' : r2;
}
function Mt(t2, e2, n2) {
  let r2 = t2 + e2;
  return void 0 !== n2 && (r2 += " " + n2), r2;
}
Ct.render = function(t2, e2, n2) {
  const r2 = Bt.getOptions(e2), o2 = t2.modules.size, i2 = t2.modules.data, s2 = o2 + 2 * r2.margin, a2 = r2.color.light.a ? "<path " + It(r2.color.light, "fill") + ' d="M0 0h' + s2 + "v" + s2 + 'H0z"/>' : "", u2 = "<path " + It(r2.color.dark, "stroke") + ' d="' + function(t3, e3, n3) {
    let r3 = "", o3 = 0, i3 = false, s3 = 0;
    for (let a3 = 0; a3 < t3.length; a3++) {
      const u3 = Math.floor(a3 % e3), c3 = Math.floor(a3 / e3);
      u3 || i3 || (i3 = true), t3[a3] ? (s3++, a3 > 0 && u3 > 0 && t3[a3 - 1] || (r3 += i3 ? Mt("M", u3 + n3, 0.5 + c3 + n3) : Mt("m", o3, 0), o3 = 0, i3 = false), u3 + 1 < e3 && t3[a3 + 1] || (r3 += Mt("h", s3), s3 = 0)) : o3++;
    }
    return r3;
  }(i2, o2, r2.margin) + '"/>', c2 = 'viewBox="0 0 ' + s2 + " " + s2 + '"', l2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + (r2.width ? 'width="' + r2.width + '" height="' + r2.width + '" ' : "") + c2 + ' shape-rendering="crispEdges">' + a2 + u2 + "</svg>\n";
  return "function" == typeof n2 && n2(null, l2), l2;
};
const vt = function() {
  return "function" == typeof Promise && Promise.prototype && Promise.prototype.then;
}, Tt = r, Nt = yt, Pt = Ct;
function bt(t2, e2, n2, r2, o2) {
  const i2 = [].slice.call(arguments, 1), s2 = i2.length, a2 = "function" == typeof i2[s2 - 1];
  if (!a2 && !vt())
    throw new Error("Callback required as last argument");
  if (!a2) {
    if (s2 < 1)
      throw new Error("Too few arguments provided");
    return 1 === s2 ? (n2 = e2, e2 = r2 = void 0) : 2 !== s2 || e2.getContext || (r2 = n2, n2 = e2, e2 = void 0), new Promise(function(o3, i3) {
      try {
        const i4 = Tt.create(n2, r2);
        o3(t2(i4, e2, r2));
      } catch (t3) {
        i3(t3);
      }
    });
  }
  if (s2 < 2)
    throw new Error("Too few arguments provided");
  2 === s2 ? (o2 = n2, n2 = e2, e2 = r2 = void 0) : 3 === s2 && (e2.getContext && void 0 === o2 ? (o2 = r2, r2 = void 0) : (o2 = r2, r2 = n2, n2 = e2, e2 = void 0));
  try {
    const i3 = Tt.create(n2, r2);
    o2(null, t2(i3, e2, r2));
  } catch (t3) {
    o2(t3);
  }
}
n.create = Tt.create, n.toCanvas = bt.bind(null, Nt.render), n.toDataURL = bt.bind(null, Nt.renderToDataURL), n.toString = bt.bind(null, function(t2, e2, n2) {
  return Pt.render(t2, n2);
});
export { n as b };
